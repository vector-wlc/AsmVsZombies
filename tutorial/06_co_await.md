<!--
 * @Coding: utf-8
 * @Author: vector-wlc
 * @Date: 2022-11-18 19:11:49
 * @Description: 
-->
# 时间管理: 阻塞

注意使用阻塞功能时必须使用 `ACoroutine ACoScript()` 形式的入口函数，否则会编译运行失败
在 PvZ 键控过程中，只有操作是不够的，还需要使操作在指定时间点运行，阻塞是实现这个需求的功能之一

例：在 (1, -599) 也就是游戏一开始的时候将寒冰菇种在一行一列

```C++
co_await ATime(1, -599);
ACard(AICE_SHROOM, 1, 1);
```

那么我相信你可以写出在 (1, 0) 的时候发一门炮的代码了。 此时屏幕前的你：写啥写，我都不知道你这个框架如何发炮。 
啊这，看法宝：

```C++
co_await ATime(1, 0);
aCobManager.Fire(1, 1); // 此行代码将会调用一门炮发送到一行一列
```

乍一看上面的代码 `Fire(1, 1)` 能看懂，但是前面这个 `aCobManager.` 是什么东东，这里实际上不需要理解，
现在咱们只需要记住用炮的时候写一个这玩意就行了，理解不了还不会照葫芦画瓢吗。

现在我们深入探讨一下上面几行代码，`co_await ATime` 这个函数到底做了什么，让操作可以在我们想要的时间点运行呢？
实际上很简单，顾名思义，`co_await ATime` 等待直到，其实就是阻塞，就是 `co_await ATime` 相当于一个拦路虎，
如果时间没到他的参数，他就会一直让脚本卡在这动不了，只有他的参数时间点到达了，他才会让程序继续运行下面的代码，
OK，了解了这个玩意的工作原理之后，我们就得不得说一说他的优点和缺点了。

### 优点
这个玩意的优点是啥呢，很简单，程序的可读性很高，看下面的代码

```C++
co_await ATime(1, -599);
ACard(AICE_SHROOM, 1, 1);
co_await ATime(1, 0);
aCobManager.Fire(1, 1); // 此行代码将会调用一门炮发送到一行一列
```

聪明的你一下就能看出来，奥这不就是前面两个代码的粘贴复制了一下吗，咳咳咳，咱们再解释一下，
在 (1, -599) 也就是游戏一开始的时候(第一波，僵尸刷新前 599cs)将寒冰菇种在一行一列，在 (1, 0) 的时候发一门炮 (好家伙就连解释也是粘贴复制的)。
嘶，好像这优点好像没啥啊？其实我是针对于后面的教程中即将介绍的 `AConnect` 来说的，你现在只需要暂时记住 `co_await ATime` 有这个优点就行。

### 缺点

要说到这玩意的缺点我可就不困了，首先他不允许时间点靠后运行的操作写在前面，比如

```C++
co_await ATime(1, 0);
aCobManager.Fire(1, 1); // 此行代码将会调用一门炮发送到一行一列
co_await ATime(1, -599);
ACard(AICE_SHROOM, 1, 1);
```

咱们详细的分析一下上面的代码，第一行代码就是将脚本的运行直接阻塞到了 (1, 0) 这个时间点，那么发炮这个操作
运行的时间点实际上是没什么毛病的，但是后面的用卡可就出大问题，人家本来是在(1, -599)这个时间点运行，
但是现在时间点已经到了 (1, 0)，显然由于脚本的运行速度不可能超过光速，易证时间不可能倒流，所以这时候脚本就会报错：
现在时间已到 (1, 0)，但是您要求的阻塞结束时间为 (1, -599)，此阻塞无意义。
所以，这就是这个玩意的巨大缺点，就是书写顺序必须和时间先后顺序严格一致，不然直接 G。
所以在脚本的最外层使用阻塞不是一个明智的选择，但是他和接下来要说的连接联合使用，会迸发出相当大的威力

[目录](./00_catalogue.md)